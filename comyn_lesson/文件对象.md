# 文件对象  IO 

使用标准库操作IO。

狭义的IO，专指文件IO。

## 打开和关闭文件：

```python 
f = open("./hello.py")   # 使用open打开文件，返回值是一个File-like对象；
f.read()   # 使用read读文件
f.close()  # close方法关闭文件；
```

## 文件对象的操作：

* 读 
* 写 

文件的操作和文件的打开方式是强相关的；

文件打开方式和文件操作的相关性：

```python
open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
```

mode:

* 'r'       open for reading (default)
* 'w'       open for writing, **truncating the file first  # 会清空原文件；写入；**
* 'x'       create a new file and open it for writing
* 'a'       open for writing, appending to the end of the file if it exists
* 'b'       binary mode
* 't'       text mode (default)
* '+'       open a disk file for updating (reading and writing)
* 'U'       universal newline mode (deprecated)


### mode=r:

    mode默认为rt，可读但不可写；

    以r模式打开不存在的文件时，会抛出FileNotFoundError.

### mode=w:

    以w模式打开的文件，可写不可读，覆盖式写入；

    mode='w',即使打开后不做写入操作，也会清空文件内容；当文件不存在时，会创建新文件；

    在尝试使用read方法时，会抛出异常：UnsupportOperation: not readable.

### mode=x ，新建文件，能写不能读；

    f = open('./hello.py','x')  # mode=x 当文件存在时会抛出异常FileExistsError.

### mode=a , 追加式写入；可写不可读；

    f = open('/hello.py','a') 

    mode='a' 写入的内容追加到文件的末尾；


---


控制读写的模式：

* r 只读，文件必须存在；
* w 只写，先清空文件，文件不存在会创建文件；
* x 只写，文件必须不存在；
* a 只写，追加到文件末尾；文件不存在会创建；


---

* 从读写的方面来看，只有r可读不可写，其他都是可写不可读；
* 从文件不存在来看，只有r抛出异常，其他创建新文件；
* 从文件存在来看，只有x抛出异常；
* 从是否影响原始内容来看，只有w会清空文件；



---

mode='t'  读入的内容是字符串；按字节操作；

mode='b'  读入的内容是bytes；按字节操作；

    当mode='b'时，执行file对象的write方法，参数为bytes；


```python 
In [6]: f = open("./mod.py",mode='wt')

In [7]: f.write("hello,python")
Out[7]: 12

In [8]: f.close()

In [9]: f = open("./mod.py",mode="wb")

In [10]: f.write("Golang")
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-10-46b9a72f475a> in <module>()
----> 1 f.write("Golang")

TypeError: a bytes-like object is required, not 'str'

In [11]: f.write("Golang".encode())
Out[11]: 6

In [13]: f.close()
```


**既想读，又想写：**

```python 
f = open("mode.py",mode="r+")  # 可读可写； 覆盖写入；
f = open("mode.py",mode="w+")  # 可读可写，但是会清空原有内容； 慎用；
f = open("mode.py",mode="a+")  # 可读可写，追加式写入；

f.write()
```


当打开文件的时候，解释器会持有一个指针，指向文件的某个位置；

当我们读写文件的时候，总是从指针处开始向后操作，并且移动指针；

当mode=r时，指针是指向0(文件开始).

mode=a 时，指针指向EOF(文件末尾) ,End Of File； 


```python 

In [14]: f = open('mode.py',mode='+')   # 单独的+不能工作，mode里必须有且仅有rwxa中的一个；
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-14-e18bffc689d0> in <module>()
----> 1 f = open('mode.py',mode='+')

ValueError: Must have exactly one of create/read/write/append mode and at most one plus
```

当mode包含+时，会增加额外的读写操作，也就是说原来是只读的，会增加可写的操作；原来是只写的，会增加可读的操作，但是+不改变其他行为；


```python 
In [18]: f.mode  
Out[18]: 'wt'

In [19]: f.tell   # 属性，获取当前文件指针的位置；
Out[19]: <function TextIOWrapper.tell>


# 当mode=t：
# seek()方法按字节移动文件指针，
# 当whence为start(0)(默认值),offset可以是任意整数；
# 当whence为current(1)或者end(2)，offset只能为0；

seek(cookie, whence=0, /) method of _io.TextIOWrapper instance Change stream position.
whence的三种取值：
* 0 -- start of stream (the default); offset should be zero or positive
* 1 -- current stream position; offset may be negative
* 2 -- end of stream; offset is usually negative
```

```python 
In [25]: f = open('hello.py',mode='w+')

In [27]: f.write("马哥教育")
Out[27]: 4

In [28]: f.close()

In [29]: f = open('hello.py',mode='rb')

In [30]: f.tell()
Out[30]: 0

In [34]: f.read().decode()
Out[34]: '马哥教育'

In [35]: f.seek(0)
Out[35]: 0

In [36]: f.tell()
Out[36]: 0

In [37]: f.seek(3)
Out[37]: 3

In [38]: f.read().decode()
Out[38]: '哥教育'

In [39]: f.seek(3)
Out[39]: 3

In [40]: f.seek(3,1) # whence=current(1) offset可以是任意整数;
Out[40]: 6

In [41]: f.read().decode()
Out[41]: '教育'

In [42]: f.seek(3,2)
Out[42]: 15

In [43]: f.read().decode()
Out[43]: ''

In [44]: f.seek(-3,2) # whence=end(2)时，offset可以是任意整数；
Out[44]: 9

In [45]: f.read().decode()
Out[45]: '育'

In [46]: f.tell()
Out[46]: 12

In [47]: f.seek(13)  # 向后超出范围，允许
Out[47]: 13

In [48]: f.tell()
Out[48]: 13

In [49]: f.seek(-13,2)   # 向前超出范围不允许；
---------------------------------------------------------------------------
OSError                                   Traceback (most recent call last)
<ipython-input-49-604f210eedaa> in <module>()
----> 1 f.seek(-13,2)

OSError: [Errno 22] Invalid argument
```


### mode='b' 
* 按字节移动文件指针 
* 当whence为start(0)(默认值),offset可以是任意整数；
* 当whence为current(1)或者end(2)，offset也可以是任意整数； 

* 当seek超出文件末尾，不会有异常，tell也会超出文件末尾，但是写数据的时候，还是会从文件末尾开始写；
* write操作从min(EOF,tell())处开始； 


---
文件指针总结：

* 文件指针按字节操作；
* tell方法返回当前文件位置；
* seek方法移动文件指针；
* whence参数 SEEK_SET(0),从0开始向后移动offset个字节；SEEK_CUR(1),从当前位置向后移动offset个字节；SEEK_END(3) ，从EOF向后移动offset个字符；
* offset是整数；


* 当mode为t时，whence为SEEK_CUR或者SEEK_END时，offset只能为0；
* 文件指针不能为负数；(当offset为负数时，其绝对值不能大于tell()的值；)
* 读文件的时候从文件指针(position)开始向后读；
* 写文件的时候从min(EOF,position)处开始向后写；
* 以append模式打开的时候，无论文件指针在何处，都从EOF开始写；


--- 

* bufio

* non-bufio 

buf:缓冲区；

缓冲区满的时候才写入(flush)到硬盘。

```python 
In [2]: f = open("hello.py",'wb')

In [3]: f.write(b'abc')
Out[3]: 3

In [4]: %cat hello.py

In [5]: f.flush()  # flush方法刷新缓冲区

In [6]: %cat hello.py
abc
In [7]: f.write(b'abc')
Out[7]: 3

In [8]: %cat hello.py
abc
In [9]: f.close()   # close方法，也会flush缓冲区；

In [10]: %cat hello.py
abcabc
```


---

### buffering=-1 
* 二进制模式：DEFAULT_BUFFER_SIZE
* 文本模式： DEFAULT_BUFFER_SIZE 

### buffering=0
* 二进制模式： unbuffered 
* 文本模式： 不允许

### buffering=1
* 二进制模式： 1 
* 文本模式： line buffering 

### buffering>1
* 二进制模式： buffering 
* 文本模式： DEFAULT_BUFFER_SIZE 


* 二进制模式： 判断缓冲区剩余位置是否足够存放当前字节，如果不能，先flush，再把当前字节写入缓冲区，如果当前字节大于缓冲区大小，直接flush。
* 文本模式：line buffering,遇到换行就flush，非line buffering，如果当前自建加缓冲区中的字节，超出缓冲区大小，直接flush缓冲区和当前字节。

特殊文件对象有特殊的刷新方式；比如：管道文件；

flush和close可以强制刷新缓冲区；


```python 
In [1]: f = open("hello.py",mode='w+')

In [2]: f.read()
Out[2]: ''

In [4]: f.write('hello')
Out[4]: 5

In [5]: f.writable    # 是否可写
Out[5]: <function TextIOWrapper.writable>

In [6]: f.readable    # 是否可读；
Out[6]: <function TextIOWrapper.readable>

In [7]: f.seekable    # 是否可以移动指针；
Out[7]: <function TextIOWrapper.seekable>

In [8]: f.closed      # 文件是否已关闭；
Out[8]: False

In [9]: f.readline(1)  #读入min(size,EOF-pos)个字符，如果遇到换行符，提前返回；

In [10]: f.readlines() # 一次读取所有行到一个list中，每一行为list的一个元素；

# 文件对象时可迭代对象，每次迭代一行；

for line in f.readlines(): 
    print(line)


In [11]: f.writelines(['abc\n','cbc\n'])  # writelines方法可以一次性写入多组文本；

In [12]: f.flush()

In [13]: %cat hello.py
helloabc
cbc

In [15]: f.fileno()   # 返回文件描述符；
Out[15]: 11

In [17]: f.isatty()   # 判断是否是tty终端文件；
Out[17]: False


In [19]: f.truncate()    # 清空文件；
Out[19]: 13

In [20]: f.read()
Out[20]: ''

```

以二进制格式打开文件时：

```python 
In [22]: f = open('hello.py',mode='r+b')

In [23]: f.readline()
Out[23]: b'aaaa\n'

In [24]: f.readlines()
Out[24]: [b'bbbb\n', b'cccc\n', b'dddd\n']

In [25]: help(f.readinto)

readinto(buffer, /) method of _io.BufferedRandom instance
```


打开的文件如果不close会怎么样？

```python 
In [32]: lst = []

In [34]: for x in range(2000):     # 将该文件打开2000次；
    ...:     lst.append(open('haha.txt'))
    ...:     
---------------------------------------------------------------------------
OSError                                   Traceback (most recent call last)
<ipython-input-34-482e3b316657> in <module>()
      1 for x in range(2000):
----> 2     lst.append(open('haha.txt'))
      3 

OSError: [Errno 24] Too many open files: 'haha.txt'   # 操作系统对打开文件数量有限制；使用ulimit -a 查看open files参数；

In [35]: len(lst)
Out[35]: 1011

In [36]: The history saving thread hit an unexpected error (OperationalError('unable to open database file',)).History will not be written to the database.
In [36]: 

```


```python 
# 确保文件最终会被关闭；
f = open('haha.txt')
try:
    f.write('12345')
finally:
    f.close()
```

## 上下文管理

```python 
with open('haha.txt') as f:  
    f.write('Mu haha!')     # 即使此处不可写，会报错，但依然会关闭该文件；
```

with语句(上下文管理)会在离开时自动关闭文件，但是它不会开启新的作用域；

上下文管理的是文件对象，跟open函数没什么关系；

```python 
f = open('haha.txt')
with f:
    pass 

```

---


# File-Linke 对象： 

    不是一个真实的文件，但具有文件的特性；在内存中模拟文件操作；

## StringIO 文本格式；

```python 
In [43]: from io import StringIO

In [44]: sio = StringIO()

In [45]: sio.readable()
Out[45]: True

In [46]: sio.writable()
Out[46]: True

In [47]: sio.seekable()
Out[47]: True

In [48]: sio.write('abcd')
Out[48]: 4

In [49]: sio.seek(0)
Out[49]: 0

In [50]: sio.read()
Out[50]: 'abcd'

In [57]: sio.getvalue() # getvalue 可以一次性读取全部内容，不管文件指针在哪里；
Out[57]: 'abcd'

```


## BytesIO  二进制格式；

```python 
In [51]: from io import BytesIO

In [52]: bio = BytesIO()

In [53]: bio.write(b'abcd')
Out[53]: 4

In [54]: bio.seek(0)
Out[54]: 0

In [55]: bio.read()
Out[55]: b'abcd'

In [56]: bio.getvalue() # getvalue 可以一次性读取全部内容，不管文件指针在哪里；
Out[56]: b'abcd'

In [67]: buf = bio.getbuffer()

In [68]: bio.close()
---------------------------------------------------------------------------
BufferError                               Traceback (most recent call last)
<ipython-input-68-ab7fe55091d2> in <module>()
----> 1 bio.close()

BufferError: Existing exports of data: object cannot be re-sized

In [69]: buf.release()

In [70]: bio.close()

```


## socket 套接字；   也是类文件对象；

类文件对象可以不close，但会占用内存空间，所以还是建议close类文件格式，以释放内存；

StringIO 和 BytesIO是直接存放于内存，并且不占用操作系统的打开文件数量，但Socket文件要占用操作系统的打开文件数量；



----

# 路径操作

3.4 之前只能使用: import os 

os.path是以字符串的方式操作路径的；

3.4之后:

    import pathlib # 以面向对象的方式操作路径；

```python 
In [73]: import pathlib

In [74]: cwd = pathlib.Path('.')   # cwd 被实例化为一个对象；

In [75]: cwd
Out[75]: PosixPath('.')
```

## 对目录的操作：

```python 
In [76]: cwd.is_dir()  # 判断对象是不是一个目录；
Out[76]: True

In [77]: cwd.iterdir() # 返回遍历目录的生成器；
Out[77]: <generator object Path.iterdir at 0x7f8319e786d0>

In [78]: for f in cwd.iterdir():  # 遍历目录，但不会递归遍历；
    ...:     print(f)
    ...:     
Python文件对象及os、os.path和pickle模块.md
Python模块.md
Python编程之MySQLdb模块.md
_book
Python程序控制结构.md
Python内置类型.md
Atom.md
book.json
```

```python 
# 创建目录：
In [80]: cwd.mkdir('abcd') # 不对的
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-80-4f62fe5954b0> in <module>()
----> 1 cwd.mkdir('abcd') # 不对的

/home/sslinux/.pyenv/versions/3.5.2/lib/python3.5/pathlib.py in mkdir(self, mode, parents, exist_ok)
   1212         if not parents:
   1213             try:
-> 1214                 self._accessor.mkdir(self, mode)
   1215             except FileExistsError:
   1216                 if not exist_ok or not self.is_dir():

/home/sslinux/.pyenv/versions/3.5.2/lib/python3.5/pathlib.py in wrapped(pathobj, *args)
    369         @functools.wraps(strfunc)
    370         def wrapped(pathobj, *args):
--> 371             return strfunc(str(pathobj), *args)
    372         return staticmethod(wrapped)
    373 

TypeError: an integer is required (got type str)

In [81]: d = pathlib.Path('./abcd') # 先初始化要创建的目录对象；

In [82]: d.exists() # 该目录是不存在的；
Out[82]: False

In [83]: d.mkdir(0o755)   # 创建目录时，要给予权限； 0o 表示是八进制；

In [84]: %ls -d ./abcd
./abcd/

In [85]: %ls -ld ./abcd
drwxr-xr-x 2 sslinux sslinux 4096 2月  25 10:45 ./abcd/
```
mkdir(mode=511, parents=False, exist_ok=False) method of pathlib.PosixPath instance

```python 
d.rmdir() # 只能删除空目录，通常不用它；

In [88]: d.mkdir(parents=True)  # parents=True 自动创建父目录；相当于mkdir -p 

In [89]: %ls -ld  ab/cd/ef
drwxrwxr-x 2 sslinux sslinux 4096 2月  25 10:54 ab/cd/ef/

In [90]: d.mkdir(parents=True,exist_ok=True)  # exist_ok=True,如果目录已存在也不会报错；

```


## 通用操作：

```python 
In [93]: f = pathlib.Path('./ab/cd/a.txt')

In [94]: f.exists()   # 判断路径是否存在；
Out[94]: False

In [95]: f.is_file() # 当文件不存在，is_*方法都返回false。
Out[95]: False

In [96]: f = pathlib.Path('./hello.py')

In [97]: f.is_file()
Out[97]: True

In [98]: f.absolute()
Out[98]: PosixPath('/home/sslinux/Desktop/MagePython/hello.py')

In [99]: f.absolute().as_uri()
Out[99]: 'file:///home/sslinux/Desktop/MagePython/hello.py'

In [100]: f.cwd()
Out[100]: PosixPath('/home/sslinux/Desktop/MagePython')

In [101]: f.drive   # windows 特有，
Out[101]: ''

In [102]: f.expanduse()
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-102-e77832c9de5b> in <module>()
----> 1 f.expanduse()

AttributeError: 'PosixPath' object has no attribute 'expanduse'

In [103]: f.expanduser()
Out[103]: PosixPath('hello.py')

In [104]: f.home()
Out[104]: PosixPath('/home/sslinux')

In [105]: f.lchmod(0o755)   # 如果一个路径是一个符号链接，修改符号链接本身的权限；
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-105-ff7517a14f3c> in <module>()
----> 1 f.lchmod()   # 如果一个路径是一个符号链接，修改符号链接本身的权限；

TypeError: lchmod() missing 1 required positional argument: 'mode'

In [106]: f.name
Out[106]: 'hello.py'

In [107]: f.home().name
Out[107]: 'sslinux'

In [108]: f.owner()
Out[108]: 'sslinux'

In [110]: f.parent
Out[110]: PosixPath('.')

In [112]: f.parents
Out[112]: <PosixPath.parents>

In [113]: f.home().parts
Out[113]: ('/', 'home', 'sslinux')

In [114]: f.home().root  #某个路径的起点；
Out[114]: '/'

In [115]: f.suffix 
Out[115]: '.py'

In [116]: f.suffixes
Out[116]: ['.py']

In [117]: f.stat()
Out[117]: os.stat_result(st_mode=33204, st_ino=1181116, st_dev=2049, st_nlink=1, st_uid=1000, st_gid=1000, st_size=20, st_atime=1487985758, st_mtime=1487985755, st_ctime=1487985755)

In [118]: # 相当于执行stat命令，

In [119]: f.lstat()   # 针对符号链接
Out[119]: os.stat_result(st_mode=33204, st_ino=1181116, st_dev=2049, st_nlink=1, st_uid=1000, st_gid=1000, st_size=20, st_atime=1487985758, st_mtime=1487985755, st_ctime=1487985755)

In [123]: d.glob('**/*.py')  # 通配符匹配；两个**表示递归；
Out[123]: <generator object Path.glob at 0x7f831a6f19e8>

In [124]: for i in d.glob('**/*.py'):
     ...:     print(x)
     ...: 

In [126]: help(d.rglob)
rglob(pattern) method of pathlib.PosixPath instance
    Recursively yield all existing files (of any kind, including
    directories) matching the given pattern, anywhere in this subtree.
```


### 路径链接：

```python 
In [128]: '/' + 'comyn' + '/' + 'workspace'
Out[128]: '/comyn/workspace'

In [129]: pathlib.Path('/','home','sslinux','workspace')
Out[129]: PosixPath('/home/sslinux/workspace')

In [130]: pathlib.Path('C:','/windows','system32')
Out[130]: PosixPath('/windows/system32')

In [131]: print(pathlib.PureWindowsPath('c:','/windows','system32'))
c:\windows\system32

In [132]: pathlib.Path('/','/home','sslinux') # 自动去除多余的/。
Out[132]: PosixPath('/home/sslinux')

In [133]: def get_home(user):
     ...:     return pathlib.Path('/home',user)
     ...: 

In [134]: get_home('sslinux')
Out[134]: PosixPath('/home/sslinux')
```


---

## shutil library

### copy,move,rm

```python 
import shutil 

# 针对文件和当前这一层的目录：
shutil.copyfileobj  # 操作对象是文件对象；
shutil.copyfile   # 仅复制内容；
shutil.copymode   # 仅复制权限；
shutil.copystat   # 仅复制元数据；
shutil.copy       # 复制文件内容和权限； copyfile + copymode 
shutil.copy2      # 复制文件内容和元数据；  copyfile + copystat 


# shutil.copytree # 递归的复制目录，copy_function参数指定使用何种方法复制文件；
```

```python 
shutil.rmtree(path,ignore_errors=False,onerror=None) 
# 用于递归删除目录，ignore_error表示是否忽略错误，
# onerror参数表示如何处理错误，仅当ignore_errors为False时，onerror才生效；ignore_errors为True时遇到错误直接排除异常。

shutil.move(src,dst,copy_function=copy2)  # 递归移动文件或目录；
# 具体实现依赖操作系统，如果操作系统实现了rename系统调用，直接走rename系统调用；
# 如果没有实现，先使用copytree，再删除原文件；

```

---

## 序列化与反序列化

* 序列化： 把对象转化为数据；
* 反序列化：把数据转为为对象；

python的序列化和反序列化操作借助pickle库完成；

```python 
In [145]: import pickle

In [146]: class A:
     ...:     def print(self):
     ...:         print('xxxx')
     ...:    

In [147]: a = A()

In [149]: b = pickle.dumps(a)

In [150]: pickle.loads(b)
Out[150]: <__main__.A at 0x7f831950b550>

In [151]: a
Out[151]: <__main__.A at 0x7f8319572208>

In [152]: aa = pickle.loads(b)

In [153]: a.print()
xxxx

In [154]: aa.print()
xxxx

```

当反序列化一个对象时，必须存在此对象的类；

虽然序列化的是对象，但是事实仅仅只是数据被序列化了；

```python 
In [4]: obj = list(range(10))

In [5]: obj
Out[5]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [6]: pickle.dumps(obj)
Out[6]: b'\x80\x03]q\x00(K\x00K\x01K\x02K\x03K\x04K\x05K\x06K\x07K\x08K\te.'

# 在另一个解释器终端里反序列化；
In [155]: pickle.loads(b'\x80\x03]q\x00(K\x00K\x01K\x02K\x03K\x04K\x05K\x06K\x07K\x08K\te.')
Out[155]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

序列化和反序列化针对的是类型和数据；

```python 
In [156]: class RPC:              # RPC:远程过程调用；
     ...:     def __init__(self):
     ...:         self.data = []
     ...:     def server(self):
     ...:         self.data = list(range(10))
     ...:     def client(self):
     ...:         print(self.data)
     ...:         

In [157]: s = RPC()

In [159]: s.server()

In [160]: s.data
Out[160]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

In [161]: pickle.dumps(s)
Out[161]: b'\x80\x03c__main__\nRPC\nq\x00)\x81q\x01}q\x02X\x04\x00\x00\x00dataq\x03]q\x04(K\x00K\x01K\x02K\x03K\x04K\x05K\x06K\x07K\x08K\tesb.'
```

凡是序列化都是需要协议的。

pickle 使用的序列化协议是Python私有协议。

所以多语言共同开发时，pickle时不能使用的。

---

通用协议：json

```python 
import json 

# json支持的数据类型：
json           python 
---------    -----------
object          dict
array           list
interger        int 
float           float 
string          str 
```


```python 
In [162]: import json

In [163]: d = {'a':1,'b':[1,2,3]}

In [164]: json.dumps(d)
Out[164]: '{"b": [1, 2, 3], "a": 1}'

In [165]: json.loads('{"b": [1, 2, 3], "a": 1}')
Out[165]: {'a': 1, 'b': [1, 2, 3]}

In [166]: pickle.dumps(d)
Out[166]: b'\x80\x03}q\x00(X\x01\x00\x00\x00bq\x01]q\x02(K\x01K\x02K\x03eX\x01\x00\x00\x00aq\x03K\x01u.'
```


## **msgpack 关注序列化后的数据尺寸。**

## **IDL: 接口定义语言。**
* thrift(apache)
* protobuf 
* avro(hadoop)
* grpc(google)


# json —— JSON encoder and decoder :

JSON(JavaScript Object Notation(n. 符号；乐谱，注释，记号法))