# 面向对象

面向对象编程：

面向对象是一种编程范式。

范式： 可以认为是一组方法论；

编程范式： 一组如何组织代码的方法论；


## 主流的编程范式：

    PP：面向过程； C语言为代表；
    IP：面向指令； 汇编为代表；更接近于机器；
    FP：函数式编程；要求：无副作用(相同的输入，得到相同的输出)
    LP：面向逻辑的编程； 抽象成与、或、非；prolog为代表，在人工智能上用得比较多；
    OOP：面向对象的编程；
    AOP：面向方面的编程；在python中的体现为装饰器；SQL；


面向对象(OOP)： 

## OOP的世界观：

* 世界是有对象组成的；
* 对象具有运动规律和内部状态；
* 对象之间可以相互作用；


OOP是以目前人类的认知来说，最接近真实世界的编程范式；

## 面向对象的特性：

* 唯一性：对象都是唯一的，不存在两个相同的对象，除非他们是同一个对象；
* 分类性：对象是可分类的；


## OOP的特征：

* 封装
* 继承 
* 多态


## Python的面向对象：

```python 
from collections import namedtuple

pet = namedtuple('Pet',['name','age'])

# 使用命名元组的目的： 为了组织数据；

lily = ('lily',3)

# 命名元组有什么优势：组织得更好，字段有名字；

Door = namedtuple('Door',['number','status'])

door = Door(1001,'closed')

print(door.number)

print(door.status)
# 能访问其属性，但是不能对其执行修改操作；
```

```python 
class Door:
    def __init__(self,number,status):
        self.number = number
        self.status = status

door = Door(1001,'closed')
print(door.status)
print(door.number)

door.status = 'opening'
print(door.status)
```

## 定义一个类：

```
class 类名:
    块
```

点号(.)用于访问对象的属性；

```python 
In [1]: class A:
   ...:     pass 
   ...: 

In [2]: a = A()

In [3]: a
Out[3]: <__main__.A at 0x7fd65ef36630>
```

* 创建对象使用`类名(__init__函数除第一个参数外的参数列表)`
* 创建对象的时候，实际执行了__init__函数；


```python 
In [13]: class D:
    ...:     def __init__(self):   # self引用的是实例变量，即实例化时的对象名称；
    ...:         print(id(self))
    ...:     
    ...:         

In [14]: d = D()
140558753338424

In [15]: id(d)
Out[15]: 140558753338424
```

* `__init__`函数不会创建对象；
* `__init__`函数初始化对象；

  - 首先创建对象；
  - 对象作为self参数传递给__init__函数；
  - 返回self 

```python 
In [17]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.status = status
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.status = 'opening'
    ...:         

In [18]: door = Door(1001,'closed')

In [19]: door.status
Out[19]: 'closed'

In [20]: Door.open(door)

In [21]: door.status
Out[21]: 'opening'

In [22]: door.status = 'closed'

In [23]: door.open()  # 当使用对象来调用的时候，第一个参数会自动的传入；

In [24]: door.status
Out[24]: 'opening'
```

小结：
* 如何定义类；
* 如何创建对象；
* 如何定义方法；
* 方法调用； 


## 作用域：

```python 
In [26]: class E:   # 类的直接下级作用域，叫做类变量；
    ...:     NAME = 'E'
    ...:     def __init__(self,name):
    ...:         self.name = name  # 关联到实例的变量，叫做实例变量；
    ...:         

In [27]: e = E('e')

In [28]: E.NAME
Out[28]: 'E'

In [29]: e.NAME
Out[29]: 'E'
# 类变量对类和实例都可见；


In [31]: e2 = E('e2')

In [32]: e2.NAME
Out[32]: 'E'

In [33]: e2.name
Out[33]: 'e2'
# 所有实例共享类变量；

In [34]: e2.NAME = 'E2'

In [35]: e2.NAME
Out[35]: 'E2'

In [36]: e.NAME
Out[36]: 'E'


# python可以动态的给实例和类增减属性：
In [37]: e.xxx = 3  
# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；

In [38]: e.xxx
Out[38]: 3

In [39]: e2.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-39-8ca2718f6555> in <module>()
----> 1 e2.xxx

AttributeError: 'E' object has no attribute 'xxx'

```

* **赋值即创建**

```python
class E:
    NAME = 'E'   # 类的直接下级作用域,叫做类变量；

    def __init__(self,name):
        self.name = name   # 关联到实例的变量，叫做实例变量；


e = E('e')
e.NAME  # 相当于：e.__class__.NAME
print(e.NAME)

print(e.__class__.NAME)


e.NAME = 'xxx' # 等价于： e.__dict__['NAME'] = 'xxx'

e.__dict__['NAME'] = 'X'

print(e.NAME)

print(e.__class__.NAME)
```

## 属性的查找顺序：
* `__dict__`
* `__class__`



## 类装饰器

```python 
def set_name(cls,name):
    cls.NAME = name
    return cls

class F:
    pass

F1 = set_name(F,'F')

f1 = F1()

print(F1.NAME)
print(f1.NAME)


def set_name(name):
    def warp(cls):
        cls.NAME = name
        return cls
    return warp

@set_name('G')
class G:
    pass

# 相当于：
# class G:
#     pass 
# 
# G = set_name('G')(G)

print(G.NAME)
```


```python
# 装饰器通常用于给类增加属性；
def print_name(cls):
    def get_name(self):
        return cls.__name__
    cls.__get_name__ = get_name
    return cls

@print_name
class H:
    pass

h = H()
print(h.__get_name__())
```


方法都是类级的；

## 类方法/静态方法

方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；


```python 
In [54]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:         

In [55]: i = I()

In [56]: i.print() # 实例调用实例方法时，会自动传入self参数，self为实例本身； I.print(i)
instance method

In [57]: I.print()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-57-acb53bc932b5> in <module>()
----> 1 I.print()

TypeError: print() missing 1 required positional argument: 'self'

In [58]: I.print(i)
instance method

```
实例方法只能由实例调用；

### 类方法：

```python 
In [59]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod    # 内置的类装饰器，使用该装饰器后，调用I.class_print()时，传递的第一个参数不再是instance，而是class本身；
    ...:     def class_print(cls): # 这样的方法是类方法；
    ...:         print('class method')
    ...:         

In [60]: I.class_print()
class method

In [61]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:         

In [62]: I.class_print()
30501992
class method

In [63]: i = I()

In [64]: i.class_print()  # 类方法可以被实例使用；并且被实例使用时，传入的第一个参数还是类；
30501992
class method
```

类方法与实例方法的区别：

    传入的第一个参数class的就是类方法；类方法无需实例化即可执行；所有实例共享；
    传入的第一个参数instance的就是实例方法；

```python 
In [65]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:     @staticmethod  # 当一个方法，被staticmethod装饰的时候，不会自动传递第一个参数，这样的方法叫静态方法；
    ...:     def static_print():
    ...:         print('static method')
    ...:         

In [66]: i = I()

In [67]: i.static_print()
static method
```

```python 
In [68]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:     @staticmethod
    ...:     def static_print():
    ...:         print('static method')
    ...:     def xxx_print(): # 不加任何装饰器，也不传递self，实例不能调用； 只是一个定义在类作用域下的函数；
            # 如果方法传入的第一个参数不是self，也没有使用任何装饰器，则其只是一个普通的类变量，只不过该变量是一个函数而已；
    ...:         print('this is a function')
    ...:         

In [69]: i = I()

In [70]: I.xxx_print()
this is a function
``` 

---

## 访问控制

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.status = status

    def open(self):   # 定义在类中的函数，被称为方法；
        self.status = 'opening'

    def close(self):
        self.status = 'closed'

door = Door(1001,'closed')
print(door.status)
door.status = 'fuck it'   # 我们希望某个属性的取值只能是规定的几个，不能自定义；
print(door.status)
```

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.__status = status  # 双下划线开始，非双下划线结尾的都是私有的，在类外部无法访问；

    def open(self):   # 定义在类中的函数，被称为方法；
        self.__status = 'opening'

    def close(self):
        self.__status = 'closed'

    def status(self):
        return self.__status
    
    def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
        self.number = number

door = Door(1001,'closed')
door.__status = 'fuck it'  # 给对象创建了新的属性，并没有修改__status。
print(door.__status)
print(door.status())
```

**所有双下划线开始，非双下划线结尾的成员，都是私有成员**

python访问私有成员：

_类名 + 带双下划线的属性

python的私有成员是通过改名实现的；

```python 
In [71]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...: 
    ...:     def status(self):
    ...:         return self.__status
    ...: 
    ...:     def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
    ...:         self.number = number
    ...:         

In [72]: door = Door(1001,'closed')

In [73]: door.__status
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-73-d55234f04e7f> in <module>()
----> 1 door.__status

AttributeError: 'Door' object has no attribute '__status'

In [75]: door._Door__status
Out[75]: 'closed'

In [76]: door._Door__status = 'opening'

In [77]: door.status()
Out[77]: 'opening'

In [78]: door._Door__status = 'fuck it'

In [79]: door.status()
Out[79]: 'fuck it'
```
### 严格的说，Python里没有真正的私有成员；

**除非真的有必要，并且清楚明白地知道会有什么后果，否则不要用这个黑魔法。90%的程序员，有生之年用不到。对封装性是一种破坏。**


### 以单下划线(_)开头的成员，是一种惯用法，标记此成员为私有，但是解释器并不做任何处理。约定俗成，不强制要求。
```python 
In [80]: class J:
    ...:     def __init__(self):
    ...:         self._a = 3
    ...:         

In [81]: j = J()

In [82]: j._a
Out[82]: 3

In [83]: j._a = 4

In [84]: j._a
Out[84]: 4

In [85]: j.__dict__
Out[85]: {'_a': 4}
```


```python 
class Door:
    def __init__(self,number,status):
        self.__number = number
        self.__status = status

    def open(self):
        self.__status = 'opening'

    def close(self):
        self.__status = 'closed'

    @property         # property装饰器会把一个仅有self参数的函数，编程一个属性；属性的值为方法的返回值；
    def status(self):
        return self.__status

    def __set_number(self,number):
        self.__number = number

    @property
    def number(self):
        return self.__number

    @number.setter   # property setter 这个装饰器，可以把一个方法转化为对此属性赋值，但此方法有一定要求：
                     # 1、同名；2、必须接受两个参数：self和value，value为所赋的值
    def number(self,number):
        if isinstance(number,int) and number > 0 and number < 10000:
            self.__number = number

    @number.deleter # 动态删除方法时，执行该方法；
    def number(self):
        print("can't remove number property")
```


## 以上内容为——封装；


## 类的继承：

```python 
# 继承的基本写法：
class Base:
    def base_print(self):
        print('base')

class A(Base):  # 在类名后加括号，括号中是继承列表； 括号中的称为父类，或者基类，或者超类；
    def a_print(self):
        print('a')

a = A()

a.a_print()
a.base_print()
```

**继承的一个明显的好处就是可以获取父类的属性和方法。代码复用**

```python 
class Base:
    PUBLIC_CLASS_VAR = 'PUBLIC_CLASS_VAR'     
    _PRIVATE_CLASS_VAR = 'PRIVATE_CLASS_VAR' 

    def __init__(self):
        self.public_instance_var = 'public_instance_var'
        self.__private_instance_var = 'private_instance_var'

    @classmethod
    def public_class_method(cls):
        return 'public_class_method'

    @classmethod
    def __private_class_method(cls):
        return 'private_class_method'

    @staticmethod
    def public_static_method():
        return 'public static method'

    @staticmethod
    def __private_static_method():
        return 'private static method'

    def public_instance_method(self):
        return 'public_instance_method'

    def __private_instance_method(self):
        return 'private_instance_method'

class Sub(Base):
    def print(self):
        print(self.public_static_method())
```

验证：
* 凡是公有的都能继承；
* 凡是私有的都不能继承；因为私有的名称转换了。
* 原来是什么，继承过来还是什么；


---


## 方法重写：

```python 
In [90]: class Base:
    ...:     def print(self):
    ...:         print('Base.print')
    ...:         

In [91]: class Sub(Base):
    ...:     def print(self):  ## 当子类和父类有同名成员的时候，子类的成员会覆盖父类的同名成员；但是结果是无法调用父类的方法；
    ...:         print('Sub.print')
    ...:         

In [92]: sub = Sub()

In [93]: sub.print()
Sub.print
```

```python 
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def foo(self):
        self.print()  # 调用父类的print方法；

sub = Sub()

sub.foo()
```

```python
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def print(self):
        print('Sub print')

    def foo(self):
        self.print()  # 此时调用的是子类的方法；

sub = Sub()

sub.foo()
```


```python 
class Base:
    def print(self):
        print('Base.print')
        

class Sub(Base):
    def print(self):
        print('Sub print')

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；
        # super(Sub).print()
        # super(Base,Sub).print()

sub = Sub()

sub.foo()
```

```python 
class Base:
    def print(self):
        print('Base.print')

    @classmethod
    def cls_print(cls):
        print("Base.cls_print")


class Sub(Base):
    def print(self):
        print('Sub print')

    @classmethod
    def cls_print(cls):
        print("Sub.cls_print")

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；
        # super(Sub).print()
        # super(Base,Sub).print()

    @classmethod
    def cls_foo(cls):
        cls.cls_print()
        Base.cls_print()
        super().cls_print()

sub = Sub()

sub.cls_foo()
```

```python
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()

SubSub().foo()
```

```python 
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    @classmethod
    def cls_print(cls):
        print('SubSub.cls_print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()  # 代理TYPE的父类的方法，并且使用obj绑定；
                                # 第一个参数 指定调用谁的直接父类；
                                # 第二个参数 指定当调用时，传递什么作为参数； 

    @classmethod
    def cls_foo(cls):
        # 调用Base的cls_print方法；
        # Base.cls_print()
        super(Sub,cls).cls_print()

SubSub().cls_foo()
```

**super并不妨碍私有属性的保护。** 


