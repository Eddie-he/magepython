# 面向对象

面向对象是一种编程范式。

范式： 可以认为是一组方法论；

编程范式： 一组如何组织代码的方法论；


## 主流的编程范式：

    PP：面向过程； C语言为代表；
    IP：面向指令； 汇编为代表；更接近于机器；
    FP：函数式编程；要求：无副作用(相同的输入，总是能得到相同的输出)
    LP：面向逻辑的编程； 抽象成与、或、非三个逻辑状态；prolog为代表，在人工智能上用得比较多；
    OOP：面向对象的编程；
    AOP：面向方面的编程；在python中的体现为装饰器；SQL；


面向对象(OOP)： Object Oriented Programming；

## OOP的世界观：

* 世界是有对象组成的；
* 对象具有运动规律和内部状态；
* 对象之间可以相互作用；


以目前人类的认知来说，OOP是最接近真实世界的编程范式；

## 面向对象的特性：

* 唯一性：对象都是唯一的，不存在两个相同的对象，除非他们是同一个对象；
* 分类性：对象是可分类的；

程序是对世界的模拟；


## OOP的特征：

* 封装
* 继承 
* 多态


## Python的面向对象：

```python 
from collections import namedtuple

pet = namedtuple('Pet',['name','age'])

# 使用命名元组的目的： 为了组织数据；

lily = ('lily',3)

# 命名元组有什么优势：组织得更好，字段有名字；

Door = namedtuple('Door',['number','status'])

door = Door(1001,'closed')

print(door.number)

print(door.status)
# 能访问其属性，但是不能对其执行修改操作；因为元组是不可变对象；
```

```python 
class Door:
    def __init__(self,number,status):
        self.number = number
        self.status = status

door = Door(1001,'closed')
print(door.status)
print(door.number)

door.status = 'opening'
print(door.status)
```

## 定义一个类：

```python
class 类名:
    块
```

点号(.)用于访问对象的属性；

```python 
In [1]: class A:
   ...:     pass 
   ...: 

In [2]: a = A()   # 实例化对象；

In [3]: a
Out[3]: <__main__.A at 0x7fd65ef36630>
```

* 创建对象使用`类名(__init__函数中除第一个参数外的参数列表)`
* 创建对象的时候，实际执行了__init__函数；


```python 
In [13]: class D:
    ...:     def __init__(self):   # self引用的是实例变量，即实例化时的实例名称；
    ...:         print(id(self))
    ...:     
    ...:         

In [14]: d = D()
140558753338424

In [15]: id(d)
Out[15]: 140558753338424
```

* `__init__`函数不会创建对象；
* `__init__`函数初始化对象；
  - 首先创建对象；
  - 对象作为self参数传递给__init__函数；
  - 返回self 

```python 
In [17]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.status = status
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.status = 'opening'
    ...:         

In [18]: door = Door(1001,'closed')

In [19]: door.status
Out[19]: 'closed'

In [20]: Door.open(door)

In [21]: door.status
Out[21]: 'opening'

In [22]: door.status = 'closed'

In [23]: door.open()  # 当使用对象来调用的时候，第一个参数会自动的传入；

In [24]: door.status
Out[24]: 'opening'
```

方法定义在类中的好处：
* 保持一个纯净的命名空间；
* 直接使用对象来调用方法时，第一个参数(self)会自动的传入；


小结：
* 如何定义类；
* 如何创建对象；
* 如何定义方法；
* 方法调用； 


## 作用域：


```python 
In [26]: class E:   
    ...:     NAME = 'E'     # 类的直接下级作用域，叫做类变量；
    ...:     def __init__(self,name):
    ...:         self.name = name  # 关联到实例的变量，叫做实例变量；
    ...:         

In [27]: e = E('e')

In [28]: E.NAME
Out[28]: 'E'

In [29]: e.NAME
Out[29]: 'E'
# 类变量对类和实例都可见；


In [31]: e2 = E('e2')

In [32]: e2.NAME
Out[32]: 'E'

In [33]: e2.name
Out[33]: 'e2'

# 所有实例共享类变量；

In [34]: e2.NAME = 'E2'

In [35]: e2.NAME
Out[35]: 'E2'

In [36]: e.NAME
Out[36]: 'E'

# python可以动态的给实例和类增减属性：

In [37]: e.xxx = 3  

# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；

In [38]: e.xxx
Out[38]: 3

In [39]: e2.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-39-8ca2718f6555> in <module>()
----> 1 e2.xxx

AttributeError: 'E' object has no attribute 'xxx'

```

* Example：

```python
class Door:
    name = "Main door"   # 类变量，所有实例共享类变量；
    def __init__(self,number=None,status=None):
        if number == None:
            self.number = 1001   # 关联到实例的变量，叫做实例变量；
        else:
            self.number = number

        if status == None:
            if status == None:
                self.status = 'closed'
            else:
                self.status = status

door = Door(1001)
door2 = Door(1002)

# 类变量对类和实例都可见；
print(Door.name)   # Main door
print(door.name)   # Main door
print(door2.name)  # Main door

# python可以动态地给实例和类增减属性：
Door.person = 'kalaguiyin'
door.person = 'sslinux'

print(Door.person) # kalaguiyin
print(door.person) # sslinux

print(door2.person) # kalaguiyin   因为上面并没有直接给实例door2增加属性person,所以输出的是类变量：Door.person

# 当给实例的类变量赋值时，相当于动态的给这个实例增加了一个属性，覆盖了类变量；
print(Door.name)   # Main door
print(door.name)   # Main door
print(door2.name)  # Main door

door.name = "Second Door"

print(Door.name)   # Main door
print(door.name)   # Second Door
print(door2.name)  # Main door

door.xxx = 3
# print(Door.xxx)    # type object "Door" has no attribute 'xxx'
print(door.xxx)      # 3
# print(door2.xxx)     # 'Door' object has no attribute 'xxx'
```


* **赋值即创建**

```python
def outter():
    v = 3 
    def inner():
        v = 4
        
class E:
    NAME = "E"  # 类的直接下级作用域，叫做类变量；
    
    def __init__(self,name):
        self.name = name  # 关联到实例的变量，叫做实例变量；
```


## 属性的查找顺序：
* `__dict__`
* `__class__`
后续还有更多的查找顺序；

```python
In [38]: class E:
    ...:     NAME = "E"
    ...:     def __init__(self,name):
    ...:         self.name = name 
    ...:         

In [39]: e = E('e')

In [40]: e.NAME    # 相当于： e.__class__.NAME 
Out[40]: 'E'

In [41]: e.__class__.NAME
Out[41]: 'E'

In [42]: e.NAME = 'xxx'    # 相当于： e.__dict__['NAME']

In [43]: e.__dict__['NAME'] = 'X'

In [44]: e.NAME
Out[44]: 'X'

In [46]: e.__class__.NAME
Out[46]: 'E'

```


## 类装饰器

```python 
In [52]: def set_name(cls,name):
    ...:     cls.NAME = name 
    ...:     return cls
    ...: 

In [53]: class F:
    ...:     pass 
    ...: 

In [54]: F1 = set_name(F,'F')

In [55]: f1 = F1()

In [56]: F1.NAME
Out[56]: 'F'

In [57]: f1.NAME
Out[57]: 'F'

#########################################################
In [58]: def set_name(name):
    ...:     def warp(cls):
    ...:         cls.NAME = name 
    ...:         return cls 
    ...:     return warp
    ...: 

In [60]: @set_name('G')
    ...: class G:
    ...:     pass 
    ...: 

In [61]: G.NAME
Out[61]: 'G'


# 相当于：
# class G:
#     pass 
# 
# G = set_name('G')(G)

print(G.NAME)
```


```python
# 装饰器通常用于给类增加属性；

# 此处增加的是一个方法；增加方法有其他更好的实现方式；
def print_name(cls):
    def get_name(self):       # 整个get_name方法相当于写在class中的；
        return cls.__name__
    cls.__get_name__ = get_name
    return cls

@print_name
class H:    # 整个类H，被传递到print_name中作为cls；
    pass

h = H()
print(h.__get_name__())
```


* **方法都是类级的；** 


## 类方法/静态方法

方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；


```python 
In [54]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:         

In [55]: i = I()

In [56]: i.print() # 实例调用实例方法时，会自动传入self参数，self为实例本身； I.print(i)
instance method

In [57]: I.print()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-57-acb53bc932b5> in <module>()
----> 1 I.print()

TypeError: print() missing 1 required positional argument: 'self'

In [58]: I.print(i)
instance method

```
**实例方法只能由实例调用；**


## 类方法：

```python 
In [59]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod    # 内置的类装饰器，使用该装饰器后，调用I.class_print()时，传递的第一个参数不再是instance，而是class本身；
    ...:     def class_print(cls): # 这样的方法是类方法；
    ...:         print('class method')
    ...:         

In [60]: I.class_print()
class method

In [61]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:         

In [62]: I.class_print()
30501992
class method

In [63]: i = I()

In [64]: i.class_print()  # 类方法可以被实例使用；并且被实例使用时，传入的第一个参数还是类；
30501992
class method
```

类方法与实例方法的区别：

    传入的第一个参数class的就是类方法；类方法无需实例化即可执行；所有实例共享；
    传入的第一个参数instance的就是实例方法；

```python 
In [65]: class I:
    ...:     def print(self):
    ...:         print('instance method')
    ...:     @classmethod
    ...:     def class_print(cls):
    ...:         print(id(cls))
    ...:         print('class method')
    ...:     @staticmethod  # 当一个方法，被staticmethod装饰的时候，不会自动传递第一个参数，这样的方法叫静态方法；
    ...:     def static_print():
    ...:         print('static method')
    ...:         

In [66]: i = I()

In [67]: i.static_print()
static method
```

```python 
# 方法的定义都是类级的，但是有的方法使用实例调用，有的方法使用类来调用；

class I:
    def instance_print(self):
        print('instance method')

    @classmethod # 内置类装饰器，当一个方法被classmethod装饰的时候，调用该方法时，传递的第一个参数不再是instance，而是class本身；
    def class_print(cls):
        print(id(cls))
        print('class method')

    @staticmethod   # 当一个方法，被staticmethod装饰的时候，不会自动传入第一个参数，这样的方法叫静态方法；
    def static_print():
        print('static method')

    def xxx_print():    # 不加任何装饰器，也不传递self，实例不能调用； 只是一个定义在类作用域下的函数；
        print("this is a function")


i = I()

# 调用实例方法：
i.instance_print()    # 实例调用实例方法的时候，会自动传入self参数，self为实例本身；

# 调用类方法：
I.class_print()   # 37893592   class method
print(id(I))      # 37893592

i.class_print()   # 类方法可以被实例使用，并且被实例使用时，传入的第一个参数还是类；
                  # 类方法无需实例化就可以执行；

# 调用静态方法：
i.static_print()


# 调用类中定义的普通函数：
I.xxx_print()
``` 

---

## 访问控制

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.status = status

    def open(self):   # 定义在类中的函数，被称为方法；
        self.status = 'opening'

    def close(self):
        self.status = 'closed'

door = Door(1001,'closed')
print(door.status)
door.status = 'fuck it'   # 我们希望某个属性的取值只能是规定的几个，不能自定义；
print(door.status)
```

```python 
class Door:
    def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
        self.number = number
        self.__status = status  # 双下划线开始，非双下划线结尾的都是私有的，在类外部无法访问；

    def open(self):   # 定义在类中的函数，被称为方法；
        self.__status = 'opening'

    def close(self):
        self.__status = 'closed'

    def status(self):
        return self.__status
    
    def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
        self.number = number

door = Door(1001,'closed')
door.__status = 'fuck it'  # 给对象创建了新的属性，并没有修改__status。
print(door.__status)
print(door.status())
```

**所有双下划线开始，非双下划线结尾的成员，都是私有成员**

## python访问私有成员：

    _类名 + 带双下划线的属性

**python的私有成员是通过改名实现的；**

```python 
In [71]: class Door:
    ...:     def __init__(self,number,status):  # 此处的self只是习惯用法，可以是其他符合规定的标识符；
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):   # 定义在类中的函数，被称为方法；
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...: 
    ...:     def status(self):
    ...:         return self.__status
    ...: 
    ...:     def __set_number(self,number):   # 双下划线开始，非双下划线结尾的方法也是私有方法；
    ...:         self.number = number
    ...:         

In [72]: door = Door(1001,'closed')

In [73]: door.__status
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-73-d55234f04e7f> in <module>()
----> 1 door.__status

AttributeError: 'Door' object has no attribute '__status'

In [75]: door._Door__status #  _类名 + 带双下划线的属性,访问私有成员；
                            # 单下划线(_) + 类名. + 带双下划线的属性名，访问私有成员；
Out[75]: 'closed'

In [76]: door._Door__status = 'opening'

In [77]: door.status()
Out[77]: 'opening'

In [78]: door._Door__status = 'fuck it'

In [79]: door.status()
Out[79]: 'fuck it'
```
### 严格的说，Python里没有真正的私有成员；

**除非真的有必要，并且清楚明白地知道会有什么后果，否则不要用这个黑魔法(使用改名后的属性名：_Class.__attribute)。** 

**90%的程序员，有生之年用不到。对封装性是一种破坏。**

猴子补丁：

    gevent；  需要使用上述访问私有成员的方法；

### 以单下划线(_)开头的成员，是一种习惯用法，标记此成员为私有，但是解释器并不做任何处理。只是约定俗成，不强制要求。
```python 
In [80]: class J:
    ...:     def __init__(self):
    ...:         self._a = 3
    ...:         

In [81]: j = J()

In [82]: j._a
Out[82]: 3

In [83]: j._a = 4

In [84]: j._a
Out[84]: 4

In [85]: j.__dict__
Out[85]: {'_a': 4}
```

## property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；

```python 
In [73]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'

    ...:     @property          # property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；
    ...:     def status(self):
    ...:         return self.__status
    ...:         

In [74]: door = Door(1001,'closed')

In [75]: door.status
Out[75]: 'closed'

In [76]: door.status()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-76-76c604e52a9b> in <module>()
----> 1 door.status()

TypeError: 'str' object is not callable

```

```python
In [77]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 
    ...:     def set_number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number
    ...:     def number(self):
    ...:         return self.__number
    ...:     
In [79]: door = Door(1001,'closed')

In [81]: door.status
Out[81]: 'closed'

In [82]: door.number()
Out[82]: 1001

In [83]: door.set_number(5001)

In [85]: door.number()
Out[85]: 5001

In [86]: door.set_number('abcd1234')

In [87]: door.number()
Out[87]: 5001

```

```python 
In [88]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property    
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 

    ...:     @property    # property装饰器会把一个仅有self参数的函数，变成一个属性；属性的值为方法的返回值；
    ...:     def number(self):
    ...:         return self.__number
    ...:     
            # property setter 这个装饰器，可以把一个方法转化为对此属性赋值，但此方法有一定要求：
            # 1、必须和被property装饰的属性同名；
            # 2、必须接受两个参数：self和value，value为所赋的值
            # 3、前后顺序：property setter所装饰的方法在被property装饰的属性之后；
    ...:     @number.setter    
    ...:     def number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number
    ...:         

In [89]: door = Door(1001,'closed')

In [90]: door.number
Out[90]: 1001

In [91]: door.number = 5001

In [92]: door.number
Out[92]: 5001

In [93]: door.number = 'abcd1234'   # 对使用property setter装饰器的属性赋值(赋不符合要求的值，不生效)

In [94]: door.number
Out[94]: 5001

```

```python 
In [96]: class Door:
    ...:     def __init__(self,number,status):
    ...:         self.__number = number
    ...:         self.__status = status
    ...:         self.xxx = 5
    ...: 
    ...:     def open(self):
    ...:         self.__status = 'opening'
    ...: 
    ...:     def close(self):
    ...:         self.__status = 'closed'
    ...:     @property
    ...:     def status(self):
    ...:         return self.__status
    ...:     def __set_nubmer(self,number):
    ...:         self.__number = number 
    ...:     @property
    ...:     def number(self):
    ...:         return self.__number
    ...:     
    ...:     @number.setter    
    ...:     def number(self,number):
    ...:         if isinstance(number,int) and number > 0 and number < 10000:
    ...:             self.__number = number

    ...:     @number.deleter   # 动态删除经过property装饰过的方法时，执行该方法；
    ...:     def number(self):
    ...:         print("can't remove number property")
    ...:             

In [97]: door = Door(1001,'close')

In [98]: door.xxx   # 临时添加的无关紧要的属性；
Out[98]: 5

In [99]: del door.xxx   # 动态删除属性；

In [100]: door.xxx
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-100-045038705f09> in <module>()
----> 1 door.xxx

AttributeError: 'Door' object has no attribute 'xxx'

In [101]: del door.open    # 无法删除方法；
---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-101-10518c49374f> in <module>()
----> 1 del door.open

AttributeError: open

In [102]: del door.number       # 动态删除经过property装饰的方法时，执行使用property deleter装饰的方法；
can't remove number property

上述的三个经过property装饰的方法还可以使用以下的方式定义：
number = property(lambda self: self.__number,lambda self,value:self.__number = value,lambda self: print("can't remove number property"))
```

## 以上内容为——封装；


## 类的继承：

```python 
# 继承的基本写法：
class Base:
    def base_print(self):
        print('base')

class A(Base):  # 在类名后加括号，括号中是继承列表； 括号中的称为父类，或者基类，或者超类；
    def a_print(self):
        print('a')

a = A()

a.a_print()
a.base_print()
```

**继承的一个明显的好处就是可以获取父类的属性和方法。代码复用**

```python 
class Base:
    PUBLIC_CLASS_VAR = 'PUBLIC_CLASS_VAR'     
    _PRIVATE_CLASS_VAR = 'PRIVATE_CLASS_VAR' 

    def __init__(self):
        self.public_instance_var = 'public_instance_var'
        self.__private_instance_var = 'private_instance_var'

    @classmethod
    def public_class_method(cls):
        return 'public_class_method'

    @classmethod
    def __private_class_method(cls):
        return 'private_class_method'

    @staticmethod
    def public_static_method():
        return 'public static method'

    @staticmethod
    def __private_static_method():
        return 'private static method'

    def public_instance_method(self):
        return 'public_instance_method'

    def __private_instance_method(self):
        return 'private_instance_method'

class Sub(Base):
    def print(self):
        print(self.public_static_method())
```

验证：
* 凡是公有的都能继承；
* 凡是私有的都不能继承；因为私有的名称转换了。
* 原来是什么，继承过来还是什么；


---


## 方法重写：

```python 
In [90]: class Base:
    ...:     def print(self):
    ...:         print('Base.print')
    ...:         

In [91]: class Sub(Base):
    ...:     def print(self):  ## 当子类和父类有同名成员的时候，子类的成员会覆盖父类的同名成员；但是结果是无法调用父类的方法；
    ...:         print('Sub.print')
    ...:         

In [92]: sub = Sub()

In [93]: sub.print()
Sub.print
```

```python 
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def foo(self):
        self.print()  # 调用父类的print方法；

sub = Sub()

sub.foo()
```

```python
class Base:
    def print(self):
        print('Base.print')

class Sub(Base):
    def print(self):
        print('Sub print')

    def foo(self):
        self.print()  # 此时调用的是子类的方法；

sub = Sub()

sub.foo()
```


```python 
class Base:
    def print(self):
        print('Base.print')
        

class Sub(Base):
    def print(self):
        print('Sub print')

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；
        # super(Sub).print()
        # super(Base,Sub).print()

sub = Sub()

sub.foo()
```

```python 
class Base:
    def print(self):
        print('Base.print')

    @classmethod
    def cls_print(cls):
        print("Base.cls_print")


class Sub(Base):
    def print(self):
        print('Sub print')

    @classmethod
    def cls_print(cls):
        print("Sub.cls_print")

    def foo(self):
        # self.print()  # 此时调用的是子类的方法；
        super().print() # 调用的是父类的print方法；
        super(Sub,self).print() # 和前一行是一样的；
        # super(Sub).print()
        # super(Base,Sub).print()

    @classmethod
    def cls_foo(cls):
        cls.cls_print()
        Base.cls_print()
        super().cls_print()

sub = Sub()

sub.cls_foo()
```

```python
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()

SubSub().foo()
```

```python 
class SubSub(Sub):
    def print(self):
        print('SubSub.print')

    @classmethod
    def cls_print(cls):
        print('SubSub.cls_print')

    def foo(self):
        # 调用Base的print
        super(Sub,self).print()  # 代理TYPE的父类的方法，并且使用obj绑定；
                                # 第一个参数 指定调用谁的直接父类；
                                # 第二个参数 指定当调用时，传递什么作为参数； 

    @classmethod
    def cls_foo(cls):
        # 调用Base的cls_print方法；
        # Base.cls_print()
        super(Sub,cls).cls_print()

SubSub().cls_foo()
```

**super并不妨碍私有属性的保护。** 


[Python开发社区](http://www.ctolib.com)










